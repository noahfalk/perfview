using FastSerialization;
using Microsoft.Diagnostics.Tracing.EventPipe;
using Microsoft.Diagnostics.Tracing.Parsers;
using Microsoft.Diagnostics.Tracing.Parsers.Clr;
using Microsoft.Diagnostics.Tracing.Session;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

namespace Microsoft.Diagnostics.Tracing
{
    /// <summary>
    /// EventPipeEventSource knows how to decode EventPipe (generated by the .NET core runtime).
    /// Please see <see href="https://github.com/Microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeFormat.md" />for details on the file format.
    /// 
    /// By conventions files of such a format are given the .netperf suffix and are logically
    /// very much like a ETL file in that they have a header that indicate things about
    /// the trace as a whole, and a list of events.    Like more modern ETL files the
    /// file as a whole is self-describing.    Some of the events are 'MetaData' events
    /// that indicate the provider name, event name, and payload field names and types.   
    /// Ordinary events then point at these meta-data event so that logically all 
    /// events have a name some basic information (process, thread, timestamp, activity
    /// ID) and user defined field names and values of various types.  
    /// </summary>
    public unsafe class EventPipeEventSource : TraceEventDispatcher
    {
        public EventPipeEventSource(string fileName) : this(new PinnedStreamReader(fileName, 0x20000), fileName)
        {
        }

        public EventPipeEventSource(Stream stream) : this(new PinnedStreamReader(stream), "stream")
        {
        }

        private EventPipeEventSource(IStreamReader reader, string streamName)
        {
            EventPipeSourceInfo sourceInfo = null;
            if (Deserializer.HasFastSerializationHeader(reader))
            {
                _netPerfReader = new NetPerfReader(new Deserializer(reader, streamName), this);
                sourceInfo = _netPerfReader;
            }
            else
            {
                throw new SerializationException("Not a understood file format: " + streamName);
            }
            cpuSpeedMHz = sourceInfo.CpuSpeedMHz;
            numberOfProcessors = sourceInfo.NumberOfProcessors;
            osVersion = sourceInfo.OSVersion;
            pointerSize = sourceInfo.PointerSize;
            _QPCFreq = sourceInfo.QPCFreq;
            sessionStartTimeQPC = sourceInfo.SessionStartTimeQPC;
            _syncTimeQPC = sourceInfo.SyncTimeQPC;
            _syncTimeUTC = sourceInfo.SyncTimeUTC;
            _processId = sourceInfo.ProcessId;
            _expectedCPUSamplingRate = sourceInfo.ExpectedCPUSamplingRate;
        }


        #region private
        // I put these in the private section because they are overrides, and thus don't ADD to the API.  
        public override int EventsLost => 0;

        protected override void Dispose(bool disposing)
        {
            if(_netPerfReader != null)
            {
                _netPerfReader.Dispose();
                _netPerfReader = null;
            }
            base.Dispose(disposing);
        }

        public override bool Process()
        {
            if (_netPerfReader != null)
            {
                return _netPerfReader.Process();
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        internal override string ProcessName(int processID, long timeQPC) => string.Format("Process({0})", processID);

        internal override unsafe Guid GetRelatedActivityID(TraceEventNativeMethods.EVENT_RECORD* eventRecord)
        {
            if(_netPerfReader != null)
            {
                return _netPerfReader.GetRelatedActivityID(eventRecord);
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        /// <summary>
        /// Give meta-data for an event, passed as a EventPipeEventMetaDataHeader and readerForParameters
        /// which is a StreamReader that points at serialized parameter information, decode the meta-data
        /// and record a template associated with this source. The readerForParameters is advanced beyond
        /// the event parameters information.  
        /// </summary>
        internal void OnNewEventPipeEventDefinition(EventPipeMetadataHeader eventMetaDataHeader, PinnedStreamReader readerForParameters)
        {
            // Convert the EventPipe data into a DynamicTraceEventData, which is how TraceEvent does dynamic event parsing.  
            DynamicTraceEventData template = ReadEventParametersAndBuildTemplate(eventMetaDataHeader, readerForParameters);
            _metadataTemplates[template] = template;
        }

        internal bool TryGetTemplateFromMetadata(TraceEvent unhandledEvent, out DynamicTraceEventData template)
        {
            return _metadataTemplates.TryGetValue(unhandledEvent, out template);
        }

        /// <summary>
        /// Given the EventPipe metaData header and a stream pointing at the serialized meta-data for the parameters for the
        /// event, create a new  DynamicTraceEventData that knows how to parse that event.  
        /// ReaderForParameters.Current is advanced past the parameter information.  
        /// </summary>
        private DynamicTraceEventData ReadEventParametersAndBuildTemplate(EventPipeMetadataHeader eventMetaDataHeader, PinnedStreamReader readerForParameters)
        {
            int opcode;
            string opcodeName;

            GetOpcodeFromEventName(eventMetaDataHeader.EventName, out opcode, out opcodeName);

            DynamicTraceEventData.PayloadFetchClassInfo classInfo = null;
            DynamicTraceEventData template = new DynamicTraceEventData(null, eventMetaDataHeader.EventId, 0, eventMetaDataHeader.EventName, Guid.Empty, opcode, opcodeName, eventMetaDataHeader.ProviderId, eventMetaDataHeader.ProviderName);

            // If the metadata contains no parameter metadata, don't attempt to read it.
            if (!eventMetaDataHeader.ContainsParameterMetadata)
            {
                template.payloadNames = new string[0];
                template.payloadFetches = new DynamicTraceEventData.PayloadFetch[0];
                return template;
            }

            // Read the count of event payload fields.
            int fieldCount = readerForParameters.ReadInt32();
            Debug.Assert(0 <= fieldCount && fieldCount < 0x4000);

            if (fieldCount > 0)
            {
                // Recursively parse the metadata, building up a list of payload names and payload field fetch objects.
                classInfo = ParseFields(readerForParameters, fieldCount);
            }
            else
            {
                classInfo = new DynamicTraceEventData.PayloadFetchClassInfo()
                {
                    FieldNames = new string[0],
                    FieldFetches = new DynamicTraceEventData.PayloadFetch[0]
                };
            }

            template.payloadNames = classInfo.FieldNames;
            template.payloadFetches = classInfo.FieldFetches;

            return template;
        }

        private DynamicTraceEventData.PayloadFetchClassInfo ParseFields(PinnedStreamReader reader, int numFields)
        {
            string[] fieldNames = new string[numFields];
            DynamicTraceEventData.PayloadFetch[] fieldFetches = new DynamicTraceEventData.PayloadFetch[numFields];

            ushort offset = 0;
            for (int fieldIndex = 0; fieldIndex < numFields; fieldIndex++)
            {
                DynamicTraceEventData.PayloadFetch payloadFetch = new DynamicTraceEventData.PayloadFetch();

                // Read the TypeCode for the current field.
                TypeCode typeCode = (TypeCode)reader.ReadInt32();

                // Fill out the payload fetch object based on the TypeCode.
                switch (typeCode)
                {
                    case TypeCode.Boolean:
                        {
                            payloadFetch.Type = typeof(bool);
                            payloadFetch.Size = 4; // We follow windows conventions and use 4 bytes for bool.
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Char:
                        {
                            payloadFetch.Type = typeof(char);
                            payloadFetch.Size = sizeof(char);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.SByte:
                        {
                            payloadFetch.Type = typeof(SByte);
                            payloadFetch.Size = sizeof(SByte);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Byte:
                        {
                            payloadFetch.Type = typeof(byte);
                            payloadFetch.Size = sizeof(byte);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Int16:
                        {
                            payloadFetch.Type = typeof(Int16);
                            payloadFetch.Size = sizeof(Int16);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.UInt16:
                        {
                            payloadFetch.Type = typeof(UInt16);
                            payloadFetch.Size = sizeof(UInt16);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Int32:
                        {
                            payloadFetch.Type = typeof(Int32);
                            payloadFetch.Size = sizeof(Int32);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.UInt32:
                        {
                            payloadFetch.Type = typeof(UInt32);
                            payloadFetch.Size = sizeof(UInt32);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Int64:
                        {
                            payloadFetch.Type = typeof(Int64);
                            payloadFetch.Size = sizeof(Int64);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.UInt64:
                        {
                            payloadFetch.Type = typeof(UInt64);
                            payloadFetch.Size = sizeof(UInt64);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Single:
                        {
                            payloadFetch.Type = typeof(Single);
                            payloadFetch.Size = sizeof(Single);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Double:
                        {
                            payloadFetch.Type = typeof(Double);
                            payloadFetch.Size = sizeof(Double);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Decimal:
                        {
                            payloadFetch.Type = typeof(Decimal);
                            payloadFetch.Size = sizeof(Decimal);
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.DateTime:
                        {
                            payloadFetch.Type = typeof(DateTime);
                            payloadFetch.Size = 8;
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case EventPipeEventSource.GuidTypeCode:
                        {
                            payloadFetch.Type = typeof(Guid);
                            payloadFetch.Size = 16;
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.String:
                        {
                            payloadFetch.Type = typeof(String);
                            payloadFetch.Size = DynamicTraceEventData.NULL_TERMINATED;
                            payloadFetch.Offset = offset;
                            break;
                        }
                    case TypeCode.Object:
                        {
                            // TypeCode.Object represents an embedded struct.

                            // Read the number of fields in the struct.  Each of these fields could be an embedded struct,
                            // but these embedded structs are still counted as single fields.  They will be expanded when they are handled.
                            int structFieldCount = reader.ReadInt32();
                            DynamicTraceEventData.PayloadFetchClassInfo embeddedStructClassInfo = ParseFields(reader, structFieldCount);
                            if (embeddedStructClassInfo == null)
                            {
                                throw new Exception("Unable to parse metadata for embedded struct.");
                            }
                            payloadFetch = DynamicTraceEventData.PayloadFetch.StructPayloadFetch(offset, embeddedStructClassInfo);
                            break;
                        }
                    default:
                        {
                            throw new NotSupportedException($"{typeCode} is not supported.");
                        }
                }

                // Read the string name of the event payload field.
                fieldNames[fieldIndex] = reader.ReadNullTerminatedUnicodeString();

                // Update the offset into the event for the next payload fetch.
                if (payloadFetch.Size >= DynamicTraceEventData.SPECIAL_SIZES || offset == ushort.MaxValue)
                {
                    offset = ushort.MaxValue;           // Indicate that the offset must be computed at run time.
                }
                else
                {
                    offset += payloadFetch.Size;
                }

                // Save the current payload fetch.
                fieldFetches[fieldIndex] = payloadFetch;
            }

            return new DynamicTraceEventData.PayloadFetchClassInfo()
            {
                FieldNames = fieldNames,
                FieldFetches = fieldFetches
            };
        }

        private static void GetOpcodeFromEventName(string eventName, out int opcode, out string opcodeName)
        {
            opcode = 0;
            opcodeName = null;

            if (eventName != null)
            {
                if (eventName.EndsWith("Start", StringComparison.OrdinalIgnoreCase))
                {
                    opcode = (int)TraceEventOpcode.Start;
                    opcodeName = nameof(TraceEventOpcode.Start);
                }
                else if (eventName.EndsWith("Stop", StringComparison.OrdinalIgnoreCase))
                {
                    opcode = (int)TraceEventOpcode.Stop;
                    opcodeName = nameof(TraceEventOpcode.Stop);
                }
            }
        }

        // Guid is not part of TypeCode (yet), we decided to use 17 to represent it, as it's the "free slot" 
        // see https://github.com/dotnet/coreclr/issues/16105#issuecomment-361749750 for more
        internal const TypeCode GuidTypeCode = (TypeCode)17;

        private Dictionary<TraceEvent, DynamicTraceEventData> _metadataTemplates = 
            new Dictionary<TraceEvent, DynamicTraceEventData>(new ExternalTraceEventParserState.TraceEventComparer());
        private NetPerfReader _netPerfReader;
        internal int _processId;
        internal int _expectedCPUSamplingRate;
        #endregion
    }

    #region private classes

    internal class EventPipeSourceInfo
    {
        public long QPCFreq;
        public long SyncTimeQPC;
        public DateTime SyncTimeUTC;
        public long SessionStartTimeQPC;
        public int PointerSize;
        public int NumberOfProcessors;
        public int CpuSpeedMHz;
        public Version OSVersion;
        public int ExpectedCPUSamplingRate;
        public int ProcessId;
    }


    /// <summary>
    /// Private utility class.
    /// 
    /// An EventPipeEventMetaDataHeader holds the information that can be shared among all
    /// instances of an EventPipe event from a particular provider.   Thus it contains
    /// things like the event name, provider, It however does NOT contain the data 
    /// about the event parameters (the names of the fields and their types), That is
    /// why this is a meta-data header and not all the meta-data.   
    /// 
    /// This class has two main functions
    ///    1. The constructor takes a PinnedStreamReader and decodes the serialized metadata
    ///       so you can access the data conveniently (but it does not decode the parameter info)
    ///    2. It remembers a EVENT_RECORD structure (from ETW) that contains this data)
    ///       and has a function GetEventRecordForEventData which converts from a 
    ///       EventPipeEventHeader (the raw serialized data) to a EVENT_RECORD (which
    ///       is what TraceEvent needs to look up the event an pass it up the stack.  
    /// </summary>
    internal unsafe class EventPipeMetadataHeader
    {
        public EventPipeMetadataHeader(int pointerSize, int processId)
        {
            // Get the event record and fill in fields that we can without deserializing anything.  
            _eventRecord = (TraceEventNativeMethods.EVENT_RECORD*)Marshal.AllocHGlobal(sizeof(TraceEventNativeMethods.EVENT_RECORD));
            ClearMemory(_eventRecord, sizeof(TraceEventNativeMethods.EVENT_RECORD));
            if (pointerSize == 4)
            {
                _eventRecord->EventHeader.Flags = TraceEventNativeMethods.EVENT_HEADER_FLAG_32_BIT_HEADER;
            }
            else
            {
                _eventRecord->EventHeader.Flags = TraceEventNativeMethods.EVENT_HEADER_FLAG_64_BIT_HEADER;
            }
            _eventRecord->EventHeader.ProcessId = processId;
        }

        ~EventPipeMetadataHeader()
        {
            if (_eventRecord != null)
            {
                if (_eventRecord->ExtendedData != null)
                {
                    Marshal.FreeHGlobal((IntPtr)_eventRecord->ExtendedData);
                }

                Marshal.FreeHGlobal((IntPtr)_eventRecord);
                _eventRecord = null;
            }
        }

        public unsafe void SetPayload(byte* payloadBytes, int payloadSize)
        {
            _eventRecord->UserDataLength = (ushort)payloadSize;
            _eventRecord->UserData = (IntPtr)payloadBytes;
        }

        public unsafe void SetStackBytes(byte* stackBytes, int stackBytesSize)
        {
            if (0 < stackBytesSize)
            {
                // Lazy allocation (destructor frees it). 
                if (_eventRecord->ExtendedData == null)
                {
                    _eventRecord->ExtendedData = (TraceEventNativeMethods.EVENT_HEADER_EXTENDED_DATA_ITEM*)Marshal.AllocHGlobal(sizeof(TraceEventNativeMethods.EVENT_HEADER_EXTENDED_DATA_ITEM));
                }

                if ((_eventRecord->EventHeader.Flags & TraceEventNativeMethods.EVENT_HEADER_FLAG_32_BIT_HEADER) != 0)
                {
                    _eventRecord->ExtendedData->ExtType = TraceEventNativeMethods.EVENT_HEADER_EXT_TYPE_STACK_TRACE32;
                }
                else
                {
                    _eventRecord->ExtendedData->ExtType = TraceEventNativeMethods.EVENT_HEADER_EXT_TYPE_STACK_TRACE64;
                }

                // DataPtr should point at a EVENT_EXTENDED_ITEM_STACK_TRACE*.  These have a ulong MatchID field which is NOT USED before the stack data.
                // Since that field is not used, I can backup the pointer by 8 bytes and synthesize a EVENT_EXTENDED_ITEM_STACK_TRACE from the raw buffer 
                // of stack data without having to copy.  
                _eventRecord->ExtendedData->DataSize = (ushort)(stackBytesSize + 8);
                _eventRecord->ExtendedData->DataPtr = (ulong)(stackBytes - 8);

                _eventRecord->ExtendedDataCount = 1;        // Mark that we have the stack data.  
            }
            else
            {
                _eventRecord->ExtendedDataCount = 0;
            }
        }

        /// <summary>
        /// This is a number that is unique to this meta-data blob.  It is expected to be a small integer
        /// that starts at 1 (since 0 is reserved) and increases from there (thus an array can be used).  
        /// It is what is matched up with EventPipeEventHeader.MetaDataId
        /// </summary>
        public int MetaDataId { get; set; }
        public bool ContainsParameterMetadata { get; set; }
        public string ProviderName { get; set; }
        public string EventName { get; set; }
        public Guid ProviderId
        {
            get { return _eventRecord->EventHeader.ProviderId; }
            set { _eventRecord->EventHeader.ProviderId = value; }
        }
        public int EventId
        {
            get { return _eventRecord->EventHeader.Id; }
            set { _eventRecord->EventHeader.Id = (ushort)value; }
        }
        public int Version
        {
            get { return _eventRecord->EventHeader.Version; }
            set { _eventRecord->EventHeader.Version = (byte)value; }
        }
        public ulong Keywords
        {
            get { return _eventRecord->EventHeader.Keyword; }
            set { _eventRecord->EventHeader.Keyword = value; }
        }
        public int Level
        {
            get { return _eventRecord->EventHeader.Level; }
            set { _eventRecord->EventHeader.Level = (byte)value; }
        }
        public byte Opcode
        {
            get { return _eventRecord->EventHeader.Opcode; }
            set { _eventRecord->EventHeader.Opcode = value; }
        }
        public int ThreadId
        {
            get { return _eventRecord->EventHeader.ThreadId; }
            set { _eventRecord->EventHeader.ThreadId = value; }
        }
        public long TimeStamp
        {
            get { return _eventRecord->EventHeader.TimeStamp; }
            set { _eventRecord->EventHeader.TimeStamp = value; }
        }
        public Guid ActivityId
        {
            get { return _eventRecord->EventHeader.ActivityId; }
            set { _eventRecord->EventHeader.ActivityId = value; }
        }

        public TraceEventNativeMethods.EVENT_RECORD* GetRawRecord()
        {
            return _eventRecord;
        }

        // this is a memset implementation.  Note that we often use the trick of assigning a pointer to a struct to *ptr = default(Type);
        // Span.Clear also now does this.  
        private static void ClearMemory(void* buffer, int length)
        {
            byte* ptr = (byte*)buffer;
            while (length > 0)
            {
                *ptr++ = 0;
                --length;
            }
        }

        private TraceEventNativeMethods.EVENT_RECORD* _eventRecord;
    }

   
    #endregion
}
